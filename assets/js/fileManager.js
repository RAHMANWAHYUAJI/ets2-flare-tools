/**
 * ETS2 Flare Editor - File Manager
 * Handles file loading, saving, and content generation
 */

const fileManager = {
    // Load .sii file
    loadSiiFile(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const content = e.target.result;
                console.log('File content loaded, parsing...');
                
                // Store original content and filename
                state.setFileContent(content, file.name);
                
                // Parse content
                const success = parser.parseSiiContent(content);
                
                if (success) {
                    ui.displayFlares();
                    ui.showFlareSection();
                    ui.enableSaveButton();
                    ui.updateFileName(file.name); // Update file name display
                    console.log('Loaded flares:', state.getFlareData());
                } else {
                    ui.showAlert('No valid flare data found in the file. Make sure it contains flare_blink or flare_vehicle definitions.', 'warning');
                }
            } catch (error) {
                console.error('Error parsing file:', error);
                ui.showAlert('Error reading file: ' + error.message + '\n\nPlease check that this is a valid .sii file with flare definitions.', 'error');
            }
        };
        
        reader.onerror = () => {
            ui.showAlert('Error reading file. Please try again.', 'error');
        };
        
        reader.readAsText(file);
    },

    // Save file using modern File System Access API or fallback
    async saveFile() {
        if (!state.hasFlares()) {
            ui.showAlert('Tidak ada data flare untuk disimpan! Silakan load file .sii terlebih dahulu.', 'warning');
            return;
        }
        
        const updatedContent = this.generateUpdatedContent();
        const filename = state.getFileName();
        
        try {
            // Try using File System Access API (modern browsers)
            if ('showSaveFilePicker' in window) {
                await this.saveWithFileSystemAPI(updatedContent, filename);
            } else {
                // Fallback to download
                this.saveWithDownload(updatedContent, filename);
            }
        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error('Error saving file:', error);
                ui.showAlert('Gagal menyimpan file: ' + error.message, 'error');
            }
        }
    },

    // Save using File System Access API
    async saveWithFileSystemAPI(content, filename) {
        const fileHandle = await window.showSaveFilePicker({
            suggestedName: filename,
            types: [{
                description: 'SII files',
                accept: { 'text/plain': ['.sii'] }
            }]
        });
        
        const writable = await fileHandle.createWritable();
        await writable.write(content);
        await writable.close();
        
        ui.showAlert(`File "${fileHandle.name}" berhasil disimpan!`, 'success');
        state.setFileContent(content, fileHandle.name);
    },

    // Save using download fallback
    saveWithDownload(content, filename) {
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.style.display = 'none';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        ui.showAlert(`File "${filename}" berhasil disimpan! (Browser akan download ke folder default)`, 'success');
        state.setFileContent(content, filename);
    },

    // Generate updated .sii content
    generateUpdatedContent() {
        let updatedContent = state.getFileContent();
        
        // If no existing content (new file), create SiiNunit wrapper
        if (!updatedContent || updatedContent.trim() === '') {
            updatedContent = `SiiNunit
{
// Generated by ETS2 Flare Editor v2.1

}`;
        }
        
        // Ensure content has SiiNunit wrapper if missing
        if (!updatedContent.includes('SiiNunit')) {
            updatedContent = `SiiNunit
{
${updatedContent.trim()}
}`;
        }
        
        // First, remove all existing flare definitions
        const flareRegex = /(flare_(?:blink|vehicle))\s*:\s*([^\s{]+)\s*{[^}]+}/g;
        const biasRegex = /bias\s*:\s*[^\s{]+\.bias\s*{[^}]+}/g;
        
        // Remove all flare and bias definitions
        updatedContent = updatedContent.replace(flareRegex, '');
        updatedContent = updatedContent.replace(biasRegex, '');
        
        // Clean up extra empty lines (multiple consecutive empty lines)
        updatedContent = updatedContent.replace(/\n\s*\n\s*\n+/g, '\n\n');
        
        // Add current flare definitions
        const flareDefinitions = this.generateFlareDefinitions();
        
        // For clean insertion, find the position just before the closing brace
        const lastBraceIndex = updatedContent.lastIndexOf('}');
        if (lastBraceIndex !== -1) {
            // Get content before closing brace and trim extra whitespace
            let beforeBrace = updatedContent.substring(0, lastBraceIndex).trim();
            const afterBrace = updatedContent.substring(lastBraceIndex);
            
            // Add flare definitions with proper spacing
            if (flareDefinitions.trim()) {
                updatedContent = beforeBrace + '\n\n' + flareDefinitions.trim() + '\n\n' + afterBrace;
            } else {
                updatedContent = beforeBrace + '\n\n' + afterBrace;
            }
        } else {
            // Fallback if no closing brace found
            updatedContent += flareDefinitions;
        }
        
        return updatedContent;
    },

    // Generate flare definitions
    generateFlareDefinitions() {
        let definitions = '\n';
        
        state.getFlareData().forEach(flare => {
            definitions += this.generateFlareDefinition(flare);
            // Bias properties now integrated directly into flare definition
        });
        
        return definitions;
    },

    // Generate individual flare definition
    generateFlareDefinition(flare) {
        let definition = `\n${flare.type} : ${flare.name}\n{\n`;
        
        // First: dir_type and light_type
        definition += `\tdir_type: ${flare.dirType}\n`;
        definition += `\tlight_type: ${flare.lightType}\n`;
        definition += `\n`; // Empty line
        
        // Second: Type-specific properties
        if (flare.type === 'flare_blink') {
            definition += `\tblink_pattern: "${flare.blinkPattern}"\n`;
            definition += `\tblink_step_length: ${flare.blinkStepLength}\n`;
            definition += `\n`; // Empty line
        }
        // flare_vehicle tidak memiliki intensity dan color di export
        // Hanya memiliki state_change_duration yang akan ditambahkan di akhir
        
        // Third: Bias properties (integrated directly if enabled)
        if (flare.hasBias) {
            definition += `\ttype: ${flare.biasType || 'spot'}\n`;
            definition += `\tsetup: ${flare.biasSetup || 'candela_hue_saturation'}\n`;
            definition += `\tdiffuse_color: ${flare.diffuseColor || '(100, 38, 100)'}\n`;
            definition += `\tspecular_color: ${flare.specularColor || '(100, 38, 100)'}\n`;
            definition += `\trange: ${flare.range || 0}\n`;
            definition += `\tforward_distance: false\n`;
            definition += `\tinner_angle: ${flare.innerAngle || 0}\n`;
            definition += `\touter_angle: ${flare.outerAngle || 0}\n`;
            definition += `\tfade_distance: ${flare.fadeDistance || 0}\n`;
            definition += `\tfade_span: ${flare.fadeSpan || 0}\n`;
            definition += `\n`; // Empty line
        }
        
        // Fourth: Model (if not empty)
        if (flare.model && flare.model.trim() !== '') {
            definition += `\tmodel: "${flare.model}"\n`;
            definition += `\n`; // Empty line
        }
        
        // Fifth: Model light source (if not empty)
        if (flare.modelLightSource && flare.modelLightSource.trim() !== '') {
            definition += `\tmodel_light_source: "${flare.modelLightSource}"\n`;
            definition += `\n`; // Empty line
        }
        
        // Sixth: State change duration (for both types)
        if (flare.stateChangeDuration !== undefined) {
            definition += `\tstate_change_duration: ${flare.stateChangeDuration}\n`;
        }
        
        definition += `}\n`;
        return definition;
    },

    // Generate bias definition
    generateBiasDefinition(flare) {
        let definition = `\nbias : ${flare.name}.bias\n{\n`;
        definition += `\ttype: ${flare.biasType}\n`;
        definition += `\tsetup: ${flare.biasSetup}\n`;
        definition += `\tdiffuse_color: ${flare.diffuseColor}\n`;
        definition += `\tspecular_color: ${flare.specularColor}\n`;
        
        if (flare.range !== undefined) definition += `\trange: ${flare.range}\n`;
        definition += `\tforward_distance: false\n`;
        if (flare.innerAngle !== undefined) definition += `\tinner_angle: ${flare.innerAngle}\n`;
        if (flare.outerAngle !== undefined) definition += `\touter_angle: ${flare.outerAngle}\n`;
        if (flare.fadeDistance !== undefined) definition += `\tfade_distance: ${flare.fadeDistance}\n`;
        if (flare.fadeSpan !== undefined) definition += `\tfade_span: ${flare.fadeSpan}\n`;
        
        definition += `}\n`;
        return definition;
    },

    // Export to different format (future feature)
    exportToJSON() {
        const data = {
            version: appConfig.version,
            flares: state.getFlareData(),
            metadata: {
                created: new Date().toISOString(),
                filename: state.getFileName()
            }
        };
        
        const jsonString = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = state.getFileName().replace('.sii', '.json');
        a.click();
        URL.revokeObjectURL(url);
    },

    // Import from JSON (future feature)
    importFromJSON(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (data.flares && Array.isArray(data.flares)) {
                    state.clearFlares();
                    data.flares.forEach(flare => state.addFlare(flare));
                    ui.displayFlares();
                    ui.showFlareSection();
                    ui.enableSaveButton();
                    ui.showAlert(`Imported ${data.flares.length} flares from JSON`, 'success');
                } else {
                    ui.showAlert('Invalid JSON format', 'error');
                }
            } catch (error) {
                ui.showAlert('Error reading JSON file: ' + error.message, 'error');
            }
        };
        reader.readAsText(file);
    }
};
